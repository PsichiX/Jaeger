###
	Native modules
###

/jaegerify ~~
	routine print(format:*i8, ...):
	~~ from IO/

/jaegerify ~~
	routine file_exists(path:*i8):i32
	~~ from IO/

/jaegerify ~~
	routine file_open(path:*i8, mode:*i8):*i32
	~~ as [fileOpen Handle <path String> <mode String>] from IO/

/jaegerify ~~
	routine file_close(handle:*i32):
	~~ as [fileClose <handle Handle>] from IO/

/jaegerify ~~
	routine file_size(handle:*i32):i32
	~~ as [fileSize Int <handle Handle>] from IO/

/jaegerify ~~
	routine file_read(handle:*i32, buffer:*i8, size:i32):i32
	~~ from IO/

/jaegerify ~~
	routine file_write(handle:*i32, buffer:*i8, size:i32):i32
	~~ from IO/

/jaegerify ~~
	routine current_time_epoch_ms():i32
	~~ as [currentTimeEpochMS Int] from System/

/jaegerify ~~
	routine current_time_steady_ms():i32
	~~ as [currentTimeSteadyMS Int] from System/

/jaegerify ~~
	routine platform():*i8
	~~ from System/

/jaegerify ~~
	routine i8_to_string_new(v:i8):*i8
	~~ from String/

/jaegerify ~~
	routine i8_bool_to_string_new(v:i8):*i8
	~~ from String/

/jaegerify ~~
	routine i16_to_string_new(v:i16):*i8
	~~ from String/

/jaegerify ~~
	routine i32_to_string_new(v:i32):*i8
	~~ from String/

/jaegerify ~~
	routine i64_to_string_new(v:i64):*i8
	~~ from String/

/jaegerify ~~
	routine u8_to_string_new(v:u8):*i8
	~~ from String/

/jaegerify ~~
	routine u8_bool_to_string_new(v:u8):*i8
	~~ from String/

/jaegerify ~~
	routine u16_to_string_new(v:u16):*i8
	~~ from String/

/jaegerify ~~
	routine u32_to_string_new(v:u32):*i8
	~~ from String/

/jaegerify ~~
	routine u64_to_string_new(v:u64):*i8
	~~ from String/

/jaegerify ~~
	routine f32_to_string_new(v:f32):*i8
	~~ from String/

/jaegerify ~~
	routine f64_to_string_new(v:f64):*i8
	~~ from String/

/jaegerify ~~
	routine string_to_i8(v:*i8):i8
	~~ from String/

/jaegerify ~~
	routine string_to_i8_bool(v:*i8):i8
	~~ from String/

/jaegerify ~~
	routine string_to_i16(v:*i8):i16
	~~ from String/

/jaegerify ~~
	routine string_to_i32(v:*i8):i32
	~~ from String/

/jaegerify ~~
	routine string_to_i64(v:*i8):i64
	~~ from String/

/jaegerify ~~
	routine string_to_u8(v:*i8):u8
	~~ from String/

/jaegerify ~~
	routine string_to_u8_bool(v:*i8):u8
	~~ from String/

/jaegerify ~~
	routine string_to_u16(v:*i8):u16
	~~ from String/

/jaegerify ~~
	routine string_to_u32(v:*i8):u32
	~~ from String/

/jaegerify ~~
	routine string_to_u64(v:*i8):u64
	~~ from String/

/jaegerify ~~
	routine string_to_f32(v:*i8):f32
	~~ from String/

/jaegerify ~~
	routine string_to_f64(v:*i8):f64
	~~ from String/

###
	Int
###

{Int
	~~ value:i32 ~~
}

[Int Int
	/let <this Int>/
	/asm ~~
		call @Int_new() => $this;
		mov void 0:i32 => $this->$value;
		~~/
	this
]

[Int_ToFloat Float <v Int>
	/let <r Float>/
	/set r 0.0/
	/asm ~~ conv $v->$value => $r->$value; ~~/
	r
]

[Int_ToString String <v Int>
	/let <r String>/
	/set r (String)/
	(String_Dispose r)
	/asm ~~
		call @i32_to_string_new($v->$value) => $r->$buffer;
		call @___CalculateStringLength___($r->$buffer) => $r->$length;
		~~/
	r
]

[Int_ToBool Bool <v Int>
	/let <r Bool>/
	/set r false/
	/asm ~~ or void $v->$value 1:i8 => $r->$value; ~~/
	r
]

[Int_ToHandle Handle <v Int>
	/let <r Handle>/
	/set r (Handle)/
	/asm ~~ mov void $v->$value => $r->$value; ~~/
	r
]

###
	Float
###

{Float
	~~ value:f32 ~~
}

[Float Float
	/let <this Float>/
	/asm ~~
		call @Float_new() => $this;
		mov void 0:f32 => $this->$value;
		~~/
	this
]

[Float_ToInt Int <v Float>
	/let <r Int>/
	/set r 0/
	/asm ~~ conv $v->$value => $r->$value; ~~/
	r
]

[Float_ToString String <v Float>
	/let <r String>/
	/set r (String)/
	(String_Dispose r)
	/asm ~~
		call @f32_to_string_new($v->$value) => $r->$buffer;
		call @___CalculateStringLength___($r->$buffer) => $r->$length;
		~~/
	r
]

[Float_ToBool Bool <v Float>
	/let <r Bool>/
	/set r false/
	/asm ~~ conv $v->$value => $r->$value; ~~/
	r
]

[Float_ToHandle Handle <v Float>
	/let <r Handle>/
	/set r (Handle)/
	/asm ~~ conv $v->$value => $r->$value; ~~/
	r
]

###
	String
###

{String
	~~ buffer:*i8 ~~
	~~ length:i32 ~~
}

[String String
	/let <this String>/
	/asm ~~
		call @String_new() => $this;
		mov void null => $this->$buffer;
		mov void 0:i32 => $this->$length;
		~~/
	this
]

[String_Dispose <this String>
	/let ~~ isnil:i8 ~~/
	/asm ~~
		nil $this->$buffer => $isnil;
		jif $isnil %failure %success;
		success:
		del $this->$buffer;
		failure:
		~~/
]

[String_ToInt Int <v String>
	/let <r Int>/
	/set r 0/
	/asm ~~ call @string_to_i32($v->$buffer) => $r->$value; ~~/
	r
]

[String_ToFloat Float <v String>
	/let <r Float>/
	/set r 0.0/
	/asm ~~ call @string_to_f32($v->$buffer) => $r->$value; ~~/
	r
]

[String_ToBool Bool <v String>
	/let <r Bool>/
	/set r false/
	/asm ~~ call @string_to_i8_bool($v->$buffer) => $r->$value; ~~/
	r
]

[String_ToHandle Handle <v String>
	/let <r Handle>/
	/set r (Handle)/
	/asm ~~ call @string_to_i32($v->$buffer) => $r->$value; ~~/
	r
]

###
	Bool
###

{Bool
	~~ value:i8 ~~
}

[Bool Bool
	/let <this Bool>/
	/asm ~~
		call @Bool_new() => $this;
		mov void 0:i8 => $this->$value;
		~~/
	this
]

[Bool_ToInt Int <v Bool>
	/let <r Int>/
	/set r 0/
	/asm ~~ conv $v->$value => $r->$value; ~~/
	r
]

[Bool_ToFloat Float <v Bool>
	/let <r Float>/
	/set r 0.0/
	/asm ~~ conv $v->$value => $r->$value; ~~/
	r
]

[Bool_ToString String <v Bool>
	/let <r String>/
	/set r (String)/
	(String_Dispose r)
	/asm ~~
		call @i8_bool_to_string_new($v->$value) => $r->$buffer;
		call @___CalculateStringLength___($r->$buffer) => $r->$length;
		~~/
	r
]

[Bool_ToHandle Handle <v Bool>
	/let <r Handle>/
	/set r (Handle)/
	/asm ~~ conv $v->$value => $r->$value; ~~/
	r
]

###
	Handle
###

{Handle
	~~ value:i32 ~~
}

[Handle Handle
	/let <this Handle>/
	/asm ~~
		call @Handle_new() => $this;
		mov void 0:i32 => $this->$value;
		~~/
	this
]

[Handle_ToInt Int <v Handle>
	/let <r Int>/
	/set r 0/
	/asm ~~ mov void $v->$value => $r->$value; ~~/
	r
]

[Handle_ToFloat Float <v Handle>
	/let <r Float>/
	/set r 0.0/
	/asm ~~ conv $v->$value => $r->$value; ~~/
	r
]

[Handle_ToString String <v Handle>
	/let <r String>/
	/set r (String)/
	(String_Dispose r)
	/asm ~~
		call @i32_to_string_new($v->$value) => $r->$buffer;
		call @___CalculateStringLength___($r->$buffer) => $r->$length;
		~~/
	r
]

[Handle_ToBool Bool <v Handle>
	/let <r Bool>/
	/set r false/
	/asm ~~ or void $v->$value 1:i8 => $r->$value; ~~/
	r
]

###
	Number arithmetics
###

[add Int <a Int> <b Int>
	/let <r Int>/
	/set r (Int)/
	/asm ~~
		add void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[sub Int <a Int> <b Int>
	/let <r Int>/
	/set r (Int)/
	/asm ~~
		sub void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[mul Int <a Int> <b Int>
	/let <r Int>/
	/set r (Int)/
	/asm ~~
		mul void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[div Int <a Int> <b Int>
	/let <r Int>/
	/set r (Int)/
	/asm ~~
		div void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[add Float <a Float> <b Float>
	/let <r Float>/
	/set r (Float)/
	/asm ~~
		add void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[sub Float <a Float> <b Float>
	/let <r Float>/
	/set r (Float)/
	/asm ~~
		sub void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[mul Float <a Float> <b Float>
	/let <r Float>/
	/set r (Float)/
	/asm ~~
		mul void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[div Float <a Float> <b Float>
	/let <r Float>/
	/set r (Float)/
	/asm ~~
		div void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[add Handle <a Handle> <b Handle>
	/let <r Handle>/
	/set r (Handle)/
	/asm ~~
		add void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[sub Handle <a Handle> <b Handle>
	/let <r Handle>/
	/set r (Handle)/
	/asm ~~
		sub void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[mul Handle <a Handle> <b Handle>
	/let <r Handle>/
	/set r (Handle)/
	/asm ~~
		mul void $a->$value $b->$value => $r->$value;
		~~/
	r
]

[div Handle <a Handle> <b Handle>
	/let <r Handle>/
	/set r (Handle)/
	/asm ~~
		div void $a->$value $b->$value => $r->$value;
		~~/
	r
]

###
	String manipulation
###

[concat String <a String> <b String>
	/let
		<r String>
		~~ len:i32 ~~
		~~ ptr:*i8 ~~
		/
	/set r (String)/
	(String_Dispose r)
	/asm ~~
		add void $a->$length $b->$length => $r->$length;
		add void $r->$length 1:i32 => $len;
		new i8 $len => $r->$buffer;
		add void 1:i32 $a->$length => $len;
		movb i8 $len $a->$buffer => $r->$buffer;
		add void $r->$buffer $a->$length => $ptr;
		add void 1:i32 $b->$length => $len;
		movb i8 $len $b->$buffer => $ptr;
		~~/
	r
]

###
	Boolean checks
###

[equals Bool <a Int> <b Int>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ eq void $a->$value $b->$value => $r->$value; ~~/
	r
]

[equals Bool <a Float> <b Float>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ eq void $a->$value $b->$value => $r->$value; ~~/
	r
]

[equals Bool <a String> <b String>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~
		call @string_compare($a->$buffer, $b->$buffer) => $r->$value;
		eq void $r->$value 0:i8 => $r->$value;
		~~/
	r
]

[equals Bool <a Handle> <b Handle>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ eq void $a->$value $b->$value => $r->$value; ~~/
	r
]

[equals Bool <a Bool> <b Bool>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ eq void $a->$value $b->$value => $r->$value; ~~/
	r
]

[less Bool <a Int> <b Int>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ ls void $a->$value $b->$value => $r->$value; ~~/
	r
]

[less Bool <a Float> <b Float>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ ls void $a->$value $b->$value => $r->$value; ~~/
	r
]

[less Bool <a String> <b String>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~
		call @string_compare($a->$buffer, $b->$buffer) => $r->$value;
		ls void $r->$value 0:i8 => $r->$value;
		~~/
	r
]

[less Bool <a Handle> <b Handle>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ ls void $a->$value $b->$value => $r->$value; ~~/
	r
]

[less Bool <a Bool> <b Bool>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ ls void $a->$value $b->$value => $r->$value; ~~/
	r
]

[greater Bool <a Int> <b Int>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ gr void $a->$value $b->$value => $r->$value; ~~/
	r
]

[greater Bool <a Float> <b Float>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ gr void $a->$value $b->$value => $r->$value; ~~/
	r
]

[greater Bool <a String> <b String>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~
		call @string_compare($a->$buffer, $b->$buffer) => $r->$value;
		gr void $r->$value 0:i8 => $r->$value;
		~~/
	r
]

[greater Bool <a Handle> <b Handle>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ gr void $a->$value $b->$value => $r->$value; ~~/
	r
]

[greater Bool <a Bool> <b Bool>
	/let <r Bool>/
	/set r (Bool)/
	/asm ~~ gr void $a->$value $b->$value => $r->$value; ~~/
	r
]

[not Bool <v Bool>
	/let <r Bool>/
	/set r true/
	/if v then [ /set r false/ ]/
	r
]

###
	IO manipulation
###

[roar <v Int>
	/asm ~~
		call @print("${i32}":*i8, $v->$value);
		~~/
]

[roar <v Float>
	/asm ~~
		call @print("${f32}":*i8, $v->$value);
		~~/
]

[roar <v String>
	/asm ~~
		call @print($v->$buffer);
		~~/
]

[roar <v Bool>
	/asm ~~
		jif $v->$value %true %false;
		true:
		call @print("true":*i8);
		goto %done;
		false:
		call @print("false":*i8);
		done:
		~~/
]

[roar <v Handle>
	/asm ~~
		call @print("#${i32}\n":*i8, $v->$value);
		~~/
]

[roarLine <v Int>
	/asm ~~
		call @print("${i32}\n":*i8, $v->$value);
		~~/
]

[roarLine <v Float>
	/asm ~~
		call @print("${f32}\n":*i8, $v->$value);
		~~/
]

[roarLine <v String>
	/asm ~~
		call @print("${*}\n":*i8, $v->$buffer);
		~~/
]

[roarLine <v Bool>
	/asm ~~
		jif $v->$value %true %false;
		true:
		call @print("true\n":*i8);
		goto %done;
		false:
		call @print("false\n":*i8);
		done:
		~~/
]

[roarLine <v Handle>
	/asm ~~
		call @print("#${i32}\n":*i8, $v->$value);
		~~/
]

[fileReadAll String <handle Handle>
	/let
		<result String>
		~~ length:i32 ~~
		~~ size:i32 ~~
		~~ address:*i32 ~~
		~~ buffer:*i8 ~~
		/
	/set result (String)/
	(String_Dispose result)
	/asm ~~
		jif $handle->$value %success %failure;
		success:
		conv $handle->$value => $address;
		call @file_size($address) => $length;
		add void $length 1:i32 => $size;
		new i8 $size => $buffer;
		call @file_read($address, $buffer, $length) => $size;
		mov void $buffer => $result->$buffer;
		mov void $size => $result->$length;
		add void $buffer $size => $buffer;
		movb i8 1:i32 "":*i8 => $buffer;
		failure:
		~~/
	result
]

[fileWriteAll <handle Handle> <content String>
	/let
		~~ size:i32 ~~
		~~ address:*i32 ~~
		/
	/asm ~~
		jif $handle->$value %success %failure;
		success:
		conv $handle->$value => $address;
		call @file_write($address, $content->$buffer, $content->$length) => $size;
		failure:
		~~/
]

[fileGetContents String <path String>
	/let
		<file Handle>
		<result String>
		/
	/set file (fileOpen path "r")/
	/set result (fileReadAll file)/
	(fileClose file)
	result
]

[fileSetContents <path String> <content String>
	/let <file Handle>/
	/set file (fileOpen path "w")/
	(fileWriteAll file content)
	(fileClose file)
]

###
	System manipulation.
###

[currentTimeEpochMS Int
	/let
		<r Int>
		~~ time:u64 ~~
		/
	/set r 0/
	/asm ~~
		call @currentTimeEpochMS() => $time;
		conv $time => $r->$value;
		~~/
	r
]

[currentTimeSteadyMS Int
	/let <r Int>/
	/set r 0/
	/asm ~~ call @currentTimeSteadyMS() => $r->$value; ~~/
	r
]

[platform String
	/let <r String>/
	/set r (String)/
	(String_Dispose r)
	/asm ~~
		call @platform() => $r->$buffer;
		call @___CalculateStringLength___($r->$buffer) => $r->$length;
		~~/
	r
]

/import "/atom.jg"/

[<template Array
	{Array?{0}
		~~ items:**?{0} ~~
		~~ count:i32 ~~
	}

	[Array?{0} Array?{0}
		/let <this Array?{0}>/
		/asm ~~
			call @Array?{0}_new() => $this;
			mov void null => $this->$items;
			mov void 0:i32 => $this->$count;
			~~/
		this
	]

	[Array?{0}_Dispose <this Array?{0}>
		/let
			~~ status:i8 ~~
			~~ iterator:i32 ~~
			~~ ptr:**?{0} ~~
			~~ val:*?{0} ~~
			/
		/if (not (isNull this)) then [
			/asm ~~
				mov void $this->$count => $iterator;
				mov void $this->$items => $ptr;
				loop:
				gr void $iterator 0:i32 => $status;
				jif $status %iteration %test;
				iteration:
				val $ptr => $val;
				call @?{0}_Unref($val, $stack) => $val;
				add void $ptr {*?{0}}:i32 => $ptr;
				sub void $iterator 1:i32 => $iterator;
				goto %loop;
				test:
				nil $this->$items => $status;
				jif $status %end %delete;
				delete:
				del $this->$items;
				end:
				~~/
		]/
	]

	[clone Array?{0} <v Array?{0}>
		/let
			<r Array?{0}>
			~~ status:i8 ~~
			~~ iterator:i32 ~~
			~~ ptr:**?{0} ~~
			~~ val:*?{0} ~~
			/
		/if (not (isNull v)) then [
			/set r (Array?{0})/
			/asm ~~
				new *?{0} $v->$count => $r->$items;
				mov void $v->$count => $r->$count;
				movb *?{0} $v->$count $v->$items => $r->$items;
				mov void $r->$count => $iterator;
				mov void $r->$items => $ptr;
				loop:
				gr void $iterator 0:i32 => $status;
				jif $status %iteration %end;
				iteration:
				val $ptr => $val;
				call @?{0}_Ref($val);
				add void $ptr {*?{0}}:i32 => $ptr;
				sub void $iterator 1:i32 => $iterator;
				goto %loop;
				end:
				~~/
		]/
		r
	]

	[isNull Bool <v Array?{0}>
		/let <r Bool>/
		/set r false/
		/asm ~~ nil $v => $r->$value; ~~/
		r
	]

	[isNullOrEmpty Bool <v Array?{0}>
		/let <r Bool>/
		/set r false/
		/if (isNull v) then [
			/set r true/
		] else [
			/if (not (greater (size v) 0)) then [
				/set r true/
			]/
		]/
		r
	]

	[size Int <v Array?{0}>
		/let <r Int>/
		/set r 0/
		/if (not (isNull v)) then [
			/asm ~~ mov void $v->$count => $r->$value; ~~/
		]/
		r
	]

	[add Array?{0} <a Array?{0}> <b Array?{0}>
		/let
			<r Array?{0}>
			~~ status:i8 ~~
			~~ size:i32 ~~
			~~ count:i32 ~~
			~~ iterator:i32 ~~
			~~ ptr:**?{0} ~~
			~~ val:*?{0} ~~
			/
		/if (isNullOrEmpty a) then [
			/if (not (isNullOrEmpty b)) then [
				/set r b/
			]/
		] elif (isNullOrEmpty b) then [
			/if (not (isNullOrEmpty a)) then [
				/set r a/
			]/
		] else [
			/set r (Array?{0})/
			(Array?{0}_Dispose r)
			/asm ~~
				add void $a->$count $b->$count => $count;
				new *?{0} $count => $r->$items;
				mov void $count => $r->$count;
				mov void $r->$items => $ptr;
				movb *?{0} $a->$count $a->$items => $ptr;
				mul void $a->$count {*?{0}}:i32 => $size;
				add void $ptr $size => $ptr;
				movb *?{0} $b->$count $b->$items => $ptr;
				mov void $r->$count => $iterator;
				mov void $r->$items => $ptr;
				loop:
				gr void $iterator 0:i32 => $status;
				jif $status %iteration %end;
				iteration:
				val $ptr => $val;
				call @?{0}_Ref($val);
				add void $ptr {*?{0}}:i32 => $ptr;
				sub void $iterator 1:i32 => $iterator;
				goto %loop;
				end:
				~~/
		]/
		r
	]

	[sub Array?{0} <v Array?{0}> <start Int> <length Int>
		/let
			<r Array?{0}>
			~~ status:i8 ~~
			~~ size:i32 ~~
			~~ count:i32 ~~
			~~ iterator:i32 ~~
			~~ ptr:**?{0} ~~
			~~ val:*?{0} ~~
			/
		/if (and (not (isNullOrEmpty v)) (and (not (isNull start)) (not (isNull length)))) then [
			/if (and (equals start 0) (equals length (size v))) then [
				/set r v/
			] elif (and (greater start 0) (and (greater length 0) (not (greater (add start length) (size v))))) then [
				/set r (Array?{0})/
				(Array?{0}_Dispose r)
				/asm ~~
					new *?{0} $length => $r->$items;
					mov void $length => $r->$count;
					mul void $start {*?{0}}:i32 => $size;
					mov void $v->$items => $ptr;
					add void $ptr $size => $ptr;
					mul void $length {*?{0}}:i32 => $size;
					movb *?{0} $length $ptr => $r->$items;
					mov void $r->$count => $iterator;
					mov void $r->$items => $ptr;
					loop:
					gr void $iterator 0:i32 => $status;
					jif $status %iteration %end;
					iteration:
					val $ptr => $val;
					call @?{0}_Ref($val);
					add void $ptr {*?{0}}:i32 => $ptr;
					sub void $iterator 1:i32 => $iterator;
					goto %loop;
					end:
					~~/
			]/
		]/
		r
	]

	[get ?{0} <v Array?{0}> <index Int>
		/let
			<r ?{0}>
			~~ offset:i32 ~~
			~~ ptr:**?{0} ~~
			/
		/if (and (not (isNullOrEmpty v)) (not (isNull index))) then [
			/if (and (less index (size v)) (not (less index 0))) then [
				/asm ~~
					mul void $index->$value {*?{0}}:i32 => $offset;
					add void $v->$items $offset => $ptr;
					val $ptr => $r;
					call @?{0}_Ref($r);
					~~/
			]/
		]/
		r
	]

	[set Array?{0} <v Array?{0}> <index Int> <value ?{0}>
		/let
			<r Array?{0}>
			~~ offset:i32 ~~
			~~ ptr:**?{0} ~~
			~~ src:**?{0} ~~
			~~ val:*?{0} ~~
			/
		/if (and (not (isNullOrEmpty v)) (and (not (isNull index)) (not (isNull value)))) then [
			/if (and (less index (size v)) (not (less index 0))) then [
				/set r (clone v)/
				/asm ~~
					mul void $index->$value {*?{0}}:i32 => $offset;
					add void $r->$items $offset => $ptr;
					val $ptr => $val;
					call @?{0}_Unref($val, $stack);
					call @?{0}_Ref($value);
					ptr $value => $src;
					movb *?{0} 1:i32 $src => $ptr;
					~~/
			] else [
				/set r v/
			]/
		]/
		r
	]

	[push Array?{0} <v Array?{0}> <item ?{0}>
		/let
			<r Array?{0}>
			~~ status:i8 ~~
			~~ size:i32 ~~
			~~ count:i32 ~~
			~~ iterator:i32 ~~
			~~ ptr:**?{0} ~~
			~~ src:**?{0} ~~
			~~ val:*?{0} ~~
			/
		/if (isNullOrEmpty v) then [
			/set r (Array?{0})/
			(Array?{0}_Dispose r)
			/asm ~~
				new *?{0} 1:i32 => $r->$items;
				mov void 1:i32 => $r->$count;
				mov void $r->$items => $ptr;
				ptr $item => $src;
				movb *?{0} 1:i32 $src => $ptr;
				call @?{0}_Ref($item);
				~~/
		] elif (isNull item) then [
			/if (not (isNullOrEmpty v)) then [
				/set r v/
			]/
		] else [
			/set r (Array?{0})/
			(Array?{0}_Dispose r)
			/asm ~~
				add void $v->$count 1:i32 => $count;
				new *?{0} $count => $r->$items;
				mov void $count => $r->$count;
				mov void $r->$items => $ptr;
				movb *?{0} $v->$count $v->$items => $ptr;
				mul void $v->$count {*?{0}}:i32 => $size;
				add void $ptr $size => $ptr;
				ptr $item => $src;
				movb *?{0} 1:i32 $src => $ptr;
				mov void $r->$count => $iterator;
				mov void $r->$items => $ptr;
				loop:
				gr void $iterator 0:i32 => $status;
				jif $status %iteration %end;
				iteration:
				val $ptr => $val;
				call @?{0}_Ref($val);
				add void $ptr {*?{0}}:i32 => $ptr;
				sub void $iterator 1:i32 => $iterator;
				goto %loop;
				end:
				~~/
		]/
		r
	]

	[pop Array?{0} <v Array?{0}>
		/let
			<r Array?{0}>
			~~ status:i8 ~~
			~~ size:i32 ~~
			~~ count:i32 ~~
			~~ iterator:i32 ~~
			~~ ptr:**?{0} ~~
			~~ val:*?{0} ~~
			/
		/if (not (isNullOrEmpty v)) then [
			/set r (Array?{0})/
			/if (greater (size v) 1) then [
				(Array?{0}_Dispose r)
				/asm ~~
					sub void $v->$count 1:i32 => $count;
					new *?{0} $count => $r->$items;
					mov void $count => $r->$count;
					mov void $r->$items => $ptr;
					movb *?{0} $count $v->$items => $ptr;
					mul void $count {*?{0}}:i32 => $size;
					add void $ptr $size => $ptr;
					val $ptr => $val;
					call @?{0}_Unref($val, $stack);
					mov void $r->$count => $iterator;
					mov void $r->$items => $ptr;
					loop:
					gr void $iterator 0:i32 => $status;
					jif $status %iteration %end;
					iteration:
					val $ptr => $val;
					call @?{0}_Ref($val);
					add void $ptr {*?{0}}:i32 => $ptr;
					sub void $iterator 1:i32 => $iterator;
					goto %loop;
					end:
					~~/
			]/
		]/
		r
	]
>]
